import logging
import re
import uuid

import requests
from ptbcontrib.postgres_persistence import PostgresPersistence
from telegram import ReplyKeyboardMarkup, Update, KeyboardButton, KeyboardButtonRequestChat, KeyboardButtonRequestUser, \
    MenuButtonWebApp, WebAppInfo, InlineKeyboardButton, ReplyKeyboardRemove, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    filters,
)
from tortoise import run_async

from utils import permission
from database.models import ExceptionModel, User
from text import get_text, Language
from settings import ACTION_START_DATE, ACTION_END_DATE
from database.utils import create_check, calculate_chance, get_checks_count, get_products_count, \
    create_user_from_contact, get_or_create_user, update_from_contact, set_user_first_name, set_user_phone, get_user, \
    create_media, delete_media, create_exception, create_check_errored
from database.settings import init_db, DEBUG, DATABASE_URL, DB_URL
from parse import parse_products
from read_qr import scan

# Enable logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
# set higher logging level for httpx to avoid all GET and POST requests being logged
logging.getLogger("httpx").setLevel(logging.WARNING)

logger = logging.getLogger(__name__)

LANGUAGE, PHOTO_OR_INFO, PHOTO, PROGRESS, CONTACT, PHONE_NUMBER, NAME, TECH = range(8)


if DEBUG:
    TOKEN = '6630982782:AAFJkEFJvpot1u2VrSjIWq3-xQMUbmhJJ5o' # test
else:
    TOKEN = '6797074619:AAEwFO66WB-WzT13_t6qG4x7c0V2ilVl86k'


async def get_menu(update):
    user_db = await get_user(update)
    info_button = MenuButtonWebApp(get_text(Language.MENU_3, user_db.language), WebAppInfo(url="https://uz.splatglobal.com/havas2024"))
    rules_button = MenuButtonWebApp(get_text(Language.MENU_4, user_db.language), WebAppInfo(url="https://uz.splatglobal.com/havas2024/pravila"))
    MENU_BUTTONS = [[get_text(Language.MENU_1, user_db.language)], [get_text(Language.MENU_2, user_db.language)], [info_button], [rules_button]]
    return MENU_BUTTONS


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    reply_keyboard = [["üá∫üáøO'zbek", "üá∑üá∫–†—É—Å—Å–∫–∏–π"]]
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–∏ —è–∑—ã–∫:\nTilni tanlang:",
        reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True, input_field_placeholder="O'zbek | –†—É—Å—Å–∫–∏–π?"
        ),
    )

    return CONTACT


async def contact(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    lang = 'ru' if update.message.text == "üá∑üá∫–†—É—Å—Å–∫–∏–π" else 'uz'
    user = update.message.from_user.to_dict()
    await get_or_create_user(user, lang)
    user_db = await get_user(update)
    g = [[KeyboardButton(
        get_text(Language.CONTACT_SHARE_MENU_1, user_db.language),
        request_contact=True,
        request_user=KeyboardButtonRequestUser(2),
    ), get_text(Language.CONTACT_SHARE_MENU_2, user_db.language)]]

    await update.message.reply_text(
        get_text(Language.ACQUAINTANCE, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            g, one_time_keyboard=True
        )
    )

    return NAME


async def name(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if update.message.contact:
        user = await update_from_contact(update)
        return await language(update, context)
    user_db = await get_user(update)
    await update.message.reply_text(
        get_text(Language.NAME, user_db.language)
    )

    return PHONE_NUMBER


async def phone_number(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_db = await set_user_first_name(update)
    await update.message.reply_text(
        get_text(Language.PHONE_NUMBER, user_db.language)
    )
    return LANGUAGE


async def language(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_db = await get_user(update)
    if update.message.text:
        match = re.search(r'^\+998\d{9}$', update.message.text)
        if not match:
            await update.message.reply_text(
                get_text(Language.PHONE_NUMBER_INCORRECT, user_db.language)
            )
            return LANGUAGE

        await set_user_phone(update)

    await update.message.reply_markdown(
        get_text(Language.SUCCESS_SIGNUP, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            await get_menu(update), one_time_keyboard=True,
        ),
    )

    return PHOTO_OR_INFO


async def photo_or_info(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_db: User = await get_user(update)
    nosuccess_reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)],
                                [get_text(Language.MENU_5, user_db.language)]]

    if not user_db.is_instruction_sended:
        await update.message.reply_video(
            video=f'video/{user_db.language}.MP4',
            caption=get_text(Language.INSTRUCTION, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True,
            ),
        )
        user_db.is_instruction_sended = True
        await user_db.save()


    await update.message.reply_text(
        get_text(Language.CHECK_PHOTO_SEND, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            nosuccess_reply_keyboard, one_time_keyboard=True,
        ),
    )

    return PHOTO


async def photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_db = await get_user(update)
    reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)], [get_text(Language.REPLY_KEYBOARD_2, user_db.language)], [get_text(Language.MENU_5, user_db.language)]]
    nosuccess_reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)], [get_text(Language.REPLY_KEYBOARD_2, user_db.language)], [get_text(Language.MENU_5, user_db.language)]]
    user = update.message.from_user.to_dict()
    logger.info(user)
    photo_file = await update.message.photo[-1].get_file()

    filename = f"media/{str(uuid.uuid4())}.jpg"

    await photo_file.download_to_drive(filename)
    media = await create_media(filename)
    result, success = scan(filename)

    if not success:
        await update.message.reply_markdown(
            get_text(Language.CHECK_1, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        return TECH
    logger.info(f"URL: {result}")

    if not result or not (type(result) is str):
        await update.message.reply_markdown(
            get_text(Language.CHECK_2, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return TECH

    match = re.search(r'^https://ofd\.soliq\.uz', result)
    if not match:
        await update.message.reply_markdown(
            get_text(Language.CHECK_2, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return TECH

    try:
        page = requests.get(result)
    except:
        await update.message.reply_markdown(
            get_text(Language.CHECK_2, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        return TECH

    if page.status_code not in [200, 201]:
        await update.message.reply_markdown(
            get_text(Language.CHECK_2, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return TECH

    logger.info(page)

    try:
        products, check_id, products_not_exist, incorrect_inn, incorrect_date = parse_products(page.text, result)
    except Exception as e:
        logger.info(e)
        logger.info("Exception work")
        message_text = f"*Username*: BOT\n*Datetime*: {update.message.date}\n*Link*: {result}\n\n*Error*: Ofd –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω"
        await context.bot.send_message(
            chat_id='-1002079896743',
            text=message_text,
            parse_mode=ParseMode.MARKDOWN
        )
        logger.info('OFD Error')
        await update.message.reply_markdown(
            get_text(Language.CHECK_ADDED, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        exception = await create_exception(update, user_db, media, ExceptionModel.ErrorTypes.OFD)
        logging.info(f"Exception created for:\n user: {user_db.first_name}\n ref: {result}\n filename: {filename}")
        return TECH

    logger.info(products)
    if products_not_exist:
        await update.message.reply_markdown(
            get_text(Language.CHECK_3, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return TECH

    if incorrect_inn:
        await update.message.reply_markdown(
            get_text(Language.CHECK_4, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return TECH

    if incorrect_date:
        await update.message.reply_markdown(
            get_text(Language.CHECK_5, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                nosuccess_reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return TECH

    created, check, bot_user = await create_check(check_id, user, products, media)
    if not created:
        await update.message.reply_markdown(
            get_text(Language.CHECK_6, user_db.language),
            reply_markup=ReplyKeyboardMarkup(
                reply_keyboard, one_time_keyboard=True
            ),
        )
        await delete_media(media)
        return PHOTO_OR_INFO

    await update.message.reply_markdown(
        get_text(Language.SUCCESS, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True
        ),
    )

    return PHOTO_OR_INFO


async def lk(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_db = await get_user(update)
    reply_keyboard = [[get_text(Language.MENU_5, user_db.language)]]
    user = update.message.from_user.to_dict()
    products_count = await get_products_count(user)
    await update.message.reply_markdown(
        get_text(Language.LK, user_db.language).format(
            first_name=user_db.first_name,
            phone_number=user_db.phone_number,
            products_count=products_count
        ),
        reply_markup=ReplyKeyboardMarkup(
            reply_keyboard, one_time_keyboard=True
        ),
    )
    return PHOTO_OR_INFO


async def tech(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_db = await get_user(update)
    nosuccess_reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)],
                                [get_text(Language.MENU_5, user_db.language)]]
    await update.message.reply_text(
        get_text(Language.TECH_ANSWER_1, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            nosuccess_reply_keyboard, one_time_keyboard=True
        )
    )
    user = update.message.from_user
    link = f"https://t.me/+{user_db.phone_number}"
    message_text = f"*Username*: @{user.username if user.username else link}\n*TG_ID*: {user_db.tg_id}\n*Datetime*: {update.message.date}\n*Language*: {user_db.language}\n*Text*: {update.message.text}\n\n@splatuz_support"
    await context.bot.send_message(
        chat_id='-1002079896743',
        text=message_text,
        parse_mode=ParseMode.MARKDOWN
    )
    return PHOTO_OR_INFO


    match1 = re.search(r'–¢–µ—Ö\. –ø–æ–¥–¥–µ—Ä–∂–∫–∞$', update.message.text)
    match2 = re.search(r'Texnik yordam$', update.message.text)
    if match1 or match2:
        await update.message.reply_text(
            get_text(Language.TECH, user_db.language)
        )
        return TECH

    # TODO: send message
    # 1002127130018
    user = update.message.from_user
    link = f"https://t.me/+{user_db.phone_number}"
    message_text = f"*Username*: @{user.username if user.username else link}\n*TG_ID*: {user_db.tg_id}\n*Datetime*: {update.message.date}\n*Language*: {user_db.language}\n*Text*: {update.message.text}\n\n@splatuz_support"
    await context.bot.send_message(
        chat_id='-1002079896743' if DEBUG else '-1002127130018',
        text=message_text,
        parse_mode=ParseMode.MARKDOWN
    )
    await update.message.reply_text(
        get_text(Language.TECH_ANSWER, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            await get_menu(update), one_time_keyboard=True
        ),
    )
    return PHOTO_OR_INFO


async def incorrect(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_db = await get_user(update)
    nosuccess_reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)],
                                [get_text(Language.MENU_5, user_db.language)]]
    await update.message.reply_markdown(
        get_text(Language.INCORRECT_COMMAND, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            nosuccess_reply_keyboard, one_time_keyboard=True
        )
    )
    return PHOTO_OR_INFO


async def incorrect_for_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_db = await get_user(update)
    g = [[KeyboardButton(
        get_text(Language.CONTACT_SHARE_MENU_1, user_db.language),
        request_contact=True,
        request_user=KeyboardButtonRequestUser(2),
    ), get_text(Language.CONTACT_SHARE_MENU_2, user_db.language)]]

    await update.message.reply_text(
        get_text(Language.ACQUAINTANCE, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            g, one_time_keyboard=True
        )
    )
    return NAME


async def incorrect_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_db = await get_user(update)
    nosuccess_reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)],
                                [get_text(Language.MENU_5, user_db.language)]]
    await update.message.reply_markdown(
        get_text(Language.CHECK_PHOTO_SEND, user_db.language),
        reply_markup=ReplyKeyboardMarkup(
            nosuccess_reply_keyboard, one_time_keyboard=True
        )
    )
    return PHOTO_OR_INFO


async def menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_db = await get_user(update)
    await update.message.reply_text(
            get_text(Language.BUTTON, user_db.language),
            allow_sending_without_reply=True,
            reply_markup=ReplyKeyboardMarkup(
                await get_menu(update), one_time_keyboard=True
            )
    )
    return PHOTO_OR_INFO


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    pass


async def restart(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_db = await get_user(update)
    if user_db:
        return await menu(update, context)
    return await start(update, context)

async def checkallcheckserrors(update: Update, context: ContextTypes.DEFAULT_TYPE):
    print("WOOOORK")
    # user_db = await get_user(update)
    user = update.message.from_user.to_dict()
    error_checks = await ExceptionModel.filter(
        solved=False
    )
    users_for_update_errors = []
    users_for_update_success = []
    for check in error_checks:
        user_db: User = await User.filter(id=check.user_id).first()
        nosuccess_reply_keyboard = [[get_text(Language.REPLY_KEYBOARD_1, user_db.language)],
                                    [get_text(Language.MENU_5, user_db.language)]]
        result, success = scan(check.path)

        if not success:
            check.result = Language.CHECK_1
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        if not result or not (type(result) is str):
            check.result = Language.CHECK_2
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        match = re.search(r'^https://ofd\.soliq\.uz', result)
        if not match:
            check.result = Language.CHECK_2
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        try:
            page = requests.get(result)
        except:
            check.result = Language.CHECK_2
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        if page.status_code not in [200, 201]:
            check.result = Language.CHECK_2
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        logger.info(page)

        try:
            products, check_id, products_not_exist, incorrect_inn, incorrect_date = parse_products(page.text, result)
        except:
            continue

        logger.info(products)
        if products_not_exist:
            check.result = Language.CHECK_3
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        if incorrect_inn:
            check.result = Language.CHECK_4
            check.solved = True
            await check.save()
            users_for_update_errors.append(check)
            await delete_media(check.path)
            continue

        if incorrect_date:
            check.result = Language.CHECK_5
            check.solved = True
            users_for_update_errors.append(check)
            await delete_media(check.path)
            await check.save()
            continue


        created, checkl, bot_user = await create_check_errored(check_id, user_db, products, check.media_id)
        if not created:
            check.result = Language.CHECK_6
            check.solved = True
            users_for_update_errors.append(check)
            await delete_media(check.path)
            await check.save()
            continue

        check.solved = True
        check.success = True
        users_for_update_success.append(check)
        await check.save()

    # await ExceptionModel.bulk_update(users_for_update_success, fields=['solved', 'success'])
    # await ExceptionModel.bulk_update(users_for_update_errors, fields=['solved', 'result'])

    # success_button_text = get_text(Language.MENU_5, user_db.language)
    # error_button_text = get_text(Language.REPLY_KEYBOARD_2, user_db.language)
    # keyboard_success = [
    #     [
    #         InlineKeyboardButton(f"^{success_button_text}$", callback_data=success_button_text),
    #     ]
    # ]
    #
    # keyboard_error = [
    #     [
    #         InlineKeyboardButton(f"^{error_button_text}$", callback_data=error_button_text),
    #     ]
    # ]

    for check in users_for_update_success:
        user_db: User = await User.filter(id=check.user_id).first()
        await context.bot.send_photo(
            chat_id=check.user_tg,
            photo=f'{check.path}',
            caption=f"{get_text(Language.SUCCESS, user_db.language)}",
            parse_mode=ParseMode.MARKDOWN
        )
    # breakpoint()
    for check in users_for_update_errors:
        user_db: User = await User.filter(id=check.user_id).first()
        await context.bot.send_photo(
            chat_id=check.user_tg,
            photo=f'{check.path}',
            caption=get_text(check.result, user_db.language),
            parse_mode=ParseMode.MARKDOWN,
        )

    await update.message.reply_text(
        f'–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö: {len(users_for_update_success) + len(users_for_update_errors)}\n\t–£—Å–ø–µ—à–Ω—ã–µ - {len(users_for_update_success)}\n\t–û—à–∏–±–æ—á–Ω—ã–µ - {len(users_for_update_errors)}'
    )


@permission
async def send_to_user_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(
        chat_id='373533031',
        text="Assalomu aleykum! ‚ù§Ô∏è\n\nSiz haftalik tanlovimizda muzlatgich yutib oldingiz!\n\nüéâLekin biz siz bilan bog'lana olmaymiz, chunki siz telefon raqamingizni ko'rsatmagansiz, iltimos, texnik yordam bo'limiga yozing - @splatuz_support va biz siz bilan bog'lanamiz üòä",
    )


@permission
async def send_segmented_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):

    # TEXT1_RU = "–í–æ–∑–º–æ–∂–Ω–æ, –≤–∞—Å –æ—Ç–≤–ª–µ–∫–ª–∏? ü§î\n\n–í—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–ª–∏—Å—å –≤ –±–æ—Ç–µ, –Ω–æ —Ç–∞–∫ –∏ –Ω–µ —Å—Ç–∞–ª–∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –∞–∫—Ü–∏–∏ üéÅ\n\n–ß—Ç–æ–±—ã –ø—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ –∏ –ø–æ–ª—É—á–∏—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–∏–≥—Ä–∞—Ç—å –±—ã—Ç–æ–≤—É—é —Ç–µ—Ö–Ω–∏–∫—É –∏–ª–∏ –ø–æ–µ–∑–¥–∫—É –≤ –¢–∞–∏–ª–∞–Ω–¥, –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:\n\n1Ô∏è‚É£ –ü—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –ª—é–±–æ–π –ø—Ä–æ–¥—É–∫—Ç SPLAT –∏–ª–∏ Biomed –≤ –º–∞–≥–∞–∑–∏–Ω–∞—Ö Havas.\n\n2Ô∏è‚É£ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –ø–æ–ª—É—á–µ–Ω–Ω—ã–π —á–µ–∫ —ç—Ç–æ–º—É –±–æ—Ç—É.\n\n3Ô∏è‚É£ –¢–µ–ø–µ—Ä—å –≤—ã —É—á–∞—Å—Ç–Ω–∏–∫ –∞–∫—Ü–∏–∏! –†–æ–∑—ã–≥—Ä—ã—à –ø—Ä–∏–∑–æ–≤ –∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é üéâ\n\n–ù–µ —É–ø—É—Å—Ç–∏—Ç–µ —Å–≤–æ–π —à–∞–Ω—Å, —Ä–æ–∑—ã–≥—Ä—ã—à –ø—Ä–∏–∑–æ–≤ —É–∂–µ –±–ª–∏–∑–∫–æ. –°—á–∞—Å—Ç–ª–∏–≤—á–∏–∫–∏ –ø—Ä–æ—à–ª–æ–π –Ω–µ–¥–µ–ª–∏ —É–∂–µ –ø–æ–ª—É—á–∏–ª–∏ —Å–≤–æ–∏ –ø–æ–¥–∞—Ä–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É–¥–∞—á—É –∏ –≤—ã! ‚ù§Ô∏è"
    # TEXT1_UZ = "Ehtimol, sizni chalg‚Äòitishgandir? ü§î\n\nSiz botda ro‚Äòyxatdan o‚Äòtdingiz, lekin shunga qaramay aksiya ishtirokchisi bo‚Äòlmadingiz üéÅ\n\nIshtirok etish va maishiy texnika yoki Tailandga sayohat yutib olish imkoniyatiga ega bo‚Äòlish uchun quyidagi harakatlarni bajaring:\n\n1Ô∏è‚É£ Istalgan SPLAT yoki Biomed mahsulotini Havas do‚Äòkonlaridan xarid qiling.\n\n2Ô∏è‚É£ Qabul qilingan chekni ushbu botga yuboring.\n\n3Ô∏è‚É£ Endi siz aksiya ishtirokchisiga aylandingiz! Sovrinlar har hafta o‚Äòynaladi üéâ\n\nImkoniyatingizni qo‚Äòldan boy bermang, sovrinlar yaqin kunlarda o‚Äòynaladi. O‚Äòtgan haftaning omadli g‚Äòoliblari sovg‚Äòalarni ham olishdi. Siz ham omadingizni sinab ko'ring! ‚ù§Ô∏è"
    # TEXT2_RU = "–£–≤–µ–ª–∏—á–∏–≤–∞–π—Ç–µ —Å–≤–æ–∏ —à–∞–Ω—Å—ã –Ω–∞ –ø–æ–±–µ–¥—É! ü§©\n\n–ù–∞–ø–æ–º–∏–Ω–∞–µ–º, —á—Ç–æ —á–µ–º –±–æ–ª—å—à–µ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –≤—ã –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç–µ, —Ç–µ–º –±–æ–ª—å—à–µ —à–∞–Ω—Å–æ–≤ –≤—ã–∏–≥—Ä–∞—Ç—å –æ–¥–∏–Ω –∏–∑ –ø—Ä–∏–∑–æ–≤: —Ö–æ–ª–æ–¥–∏–ª—å–Ω–∏–∫, —Å—Ç–∏—Ä–∞–ª—å–Ω–∞—è –º–∞—à–∏–Ω–∞, –∫–æ–Ω–¥–∏—Ü–∏–æ–Ω–µ—Ä, —Ç–µ–ª–µ–≤–∏–∑–æ—Ä –∏–ª–∏ —Ä–æ–±–æ—Ç-–ø—ã–ª–µ—Å–æ—Å.\n\n–ê —Ç–∞–∫–∂–µ, –≤ –∫–æ–Ω—Ü–µ –∞–∫—Ü–∏–∏ —Å—Ä–µ–¥–∏ –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –º—ã —Ä–∞–∑—ã–≥—Ä–∞–µ–º –≥–ª–∞–≤–Ω—ã–π –ø—Ä–∏–∑ - –ø–æ–µ–∑–¥–∫—É –≤ –¢–∞–∏–ª–∞–Ω–¥ –Ω–∞ –¥–≤–æ–∏—Ö!\n\n–†–æ–∑—ã–≥—Ä—ã—à –ø—Ä–∏–∑–æ–≤ –∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é! üéâ"
    # TEXT2_UZ = "G‚Äòalaba qozonish imkoniyatingizni oshiring! ü§©\n\nEslatib o‚Äòtamiz, qancha ko‚Äòp mahsulot ro‚Äòyxatdan o‚Äòtkazsangiz, muzlatgich, kir yuvish mashinasi, konditsioner, televizor yoki robot changyutgich kabi sovrinlardan birini yutib olish imkoniyati shunchalik yuqori bo‚Äòladi.\n\nShuningdek, aksiya yakunida biz barcha ishtirokchilar o‚Äòrtasida bosh sovrin ‚Äì Tailandga ikki kishilik sayohatni o‚Äòynaymiz!\n\nSovrinlar har hafta o‚Äòynaladi üéâ"


    TEXT_UZ = "Bugun SPLAT va BIOMED aksiyalari tugashining oxirgi kuni. Ishtirok etishga ulguring! üòçüèùÔ∏è\n\nTailandga chiptalar va uyingiz uchun maishiy texnika yutib olish imkoniyatini boy bermang! ü§©\n\nHavas do‚Äòkonlarida istalgan SPLAT yoki BIOMED mahsulotini xarid qiling, chekni @splatuz_bot telegram-botida ro‚Äòyxatdan o‚Äòtkazing va siz aksiya ishtirokchisisiz. ‚ù§Ô∏è"
    TEXT_RU = "–°–µ–≥–æ–¥–Ω—è –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–∫—Ü–∏–∏ –æ—Ç SPLAT –∏ BIOMED. –£—Å–ø–µ–π—Ç–µ –ø—Ä–∏–Ω—è—Ç—å —É—á–∞—Å—Ç–∏–µ! üòçüèùÔ∏è\n\n–ù–µ —É–ø—É—Å—Ç–∏—Ç–µ —à–∞–Ω—Å –≤—ã–∏–≥—Ä–∞—Ç—å –±–∏–ª–µ—Ç—ã –≤ –¢–∞–∏–ª–∞–Ω–¥ –∏ –±—ã—Ç–æ–≤—É—é —Ç–µ—Ö–Ω–∏–∫—É –¥–ª—è –≤–∞—à–µ–≥–æ –¥–æ–º–∞! ü§©\n\n–ö—É–ø–∏—Ç–µ –ª—é–±–æ–π –ø—Ä–æ–¥—É–∫—Ç SPLAT –∏–ª–∏ BIOMED –≤ –º–∞–≥–∞–∑–∏–Ω–∞—Ö Havas, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–π—Ç–µ —á–µ–∫ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º –±–æ—Ç–µ @splatuz_bot –∏ –≤—ã —É—á–∞—Å—Ç–Ω–∏–∫ –∞–∫—Ü–∏–∏. ‚ù§Ô∏è"

    users = await User.all()
    # breakpoint()

    for user in users:
        try:
            if user.language == 'ru':
                await context.bot.send_photo(
                    photo=open('ru2.jpg', 'rb'),
                    chat_id=user.tg_id,
                    caption=TEXT_RU
                )
            elif user.language == 'uz':
                await context.bot.send_photo(
                    photo=open('uz2.jpg', 'rb'),
                    chat_id=user.tg_id,
                    caption=TEXT_UZ
                )
        except Exception as e:
            print(f"Error: {e}")
            pass


    # users = await User.all()
    #
    # for user in users:
    #     try:
    #         if await user.checks.all().exists():
    #             if user.language == 'ru':
    #                 await context.bot.send_message(
    #                     chat_id=user.tg_id,
    #                     text=TEXT2_RU
    #                 )
    #             elif user.language == 'uz':
    #                 await context.bot.send_message(
    #                     chat_id=user.tg_id,
    #                     text=TEXT2_UZ
    #                 )
    #         else:
    #             if user.language == 'ru':
    #                 await context.bot.send_message(
    #                     chat_id=user.tg_id,
    #                     text=TEXT1_RU
    #                 )
    #             elif user.language == 'uz':
    #                 await context.bot.send_message(
    #                     chat_id=user.tg_id,
    #                     text=TEXT1_UZ
    #                 )
    #     except Exception:
    #         pass


def main() -> None:
    application = Application.builder().token(TOKEN).persistence(PostgresPersistence(url=DB_URL)).build()

    application.add_handler(CommandHandler("help", menu))
    application.add_handler(CommandHandler("checkallcheckserrors", checkallcheckserrors))
    application.add_handler(CommandHandler("sendtousermessage", send_to_user_message))
    application.add_handler(CommandHandler("sendsegmentedmessage", send_segmented_messages))

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start), CommandHandler("restart", restart)],
        states={
            NAME: [
                MessageHandler(filters.CONTACT, name),
                MessageHandler(filters.Regex("^–í–≤–µ—Å—Ç–∏ –∏–º—è$"), name),
                MessageHandler(filters.Regex("^Ismni kiritish$"), name),
                MessageHandler(filters.ALL, incorrect_for_name)
            ],
            TECH: [
                MessageHandler(filters.PHOTO, photo),
                MessageHandler(filters.Regex("^üë®‚Äçüíª –¢–µ—Ö. –ø–æ–¥–¥–µ—Ä–∂–∫–∞"), tech),
                MessageHandler(filters.Regex("^üë®‚Äçüíª Texnik yordam"), tech),
                MessageHandler(filters.Regex("^üßæ –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤—ã–π —á–µ–∫"), photo_or_info),
                MessageHandler(filters.Regex("^üßæ Yangi check yuklash"), photo_or_info),
                MessageHandler(filters.Regex("^–ú–µ–Ω—é$"), menu),
                MessageHandler(filters.Regex("^Menu$"), menu),
                # MessageHandler(filters.Regex("^.*"), tech),
                MessageHandler(filters.ALL, incorrect)
            ],
            LANGUAGE: [
                MessageHandler(filters.Regex("^.*"), language),
                MessageHandler(filters.ALL, incorrect)
            ],
            PHONE_NUMBER: [
                MessageHandler(filters.Regex("^\w+"), phone_number),
                MessageHandler(filters.ALL, incorrect),
            ],
            PHOTO_OR_INFO: [
                MessageHandler(filters.PHOTO, photo),
                MessageHandler(filters.Regex("^üßæ –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤—ã–π —á–µ–∫$"), photo_or_info),
                MessageHandler(filters.Regex("^üßæ Yangi check yuklash"), photo_or_info),
                MessageHandler(filters.Regex("^üßæ –ó–∞–≥—Ä—É–∑–∏—Ç—å —á–µ–∫$"), photo_or_info),
                MessageHandler(filters.Regex("^üßæ Chekni yuklash$"), photo_or_info),
                MessageHandler(filters.Regex("^üë§Ô∏è –õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç$"), lk),
                MessageHandler(filters.Regex("^üë§Ô∏è Shaxsiy kabinet$"), lk),
                MessageHandler(filters.Regex("^–ú–µ–Ω—é$"), menu),
                MessageHandler(filters.Regex("^Menu$"), menu),
                MessageHandler(filters.ALL, incorrect)
            ],
            CONTACT: [MessageHandler(filters.Regex("^(üá∫üáøO'zbek|üá∑üá∫–†—É—Å—Å–∫–∏–π)$"), contact), MessageHandler(filters.ALL, incorrect)],
            PHOTO: [
                MessageHandler(filters.PHOTO, photo),
                MessageHandler(filters.Regex("^üßæ –ó–∞–≥—Ä—É–∑–∏—Ç—å –Ω–æ–≤—ã–π —á–µ–∫$"), photo_or_info),
                MessageHandler(filters.Regex("^üßæ Yangi check yuklash"), photo_or_info),
                MessageHandler(filters.Regex("^–ú–µ–Ω—é$"), menu),
                MessageHandler(filters.Regex("^Menu$"), menu),
                MessageHandler(filters.ALL, incorrect_photo)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        persistent=True,
        name='splat'
    )

    application.add_handler(conv_handler)

    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    run_async(init_db())
    main()
